---
layout: post
title: 【转】微信朋友圈技术之道
keywords: 微信 朋友圈
category : 架构
tags : [架构]
---

##概述

截止到2015年7月，微信每月活跃用户约5.49亿，朋友圈每天的发表量（包括赞和评论）超过10亿，浏览量超过100亿。得益于4G网络的发展，以上数据仍有很快的增长，而且相对于PC互联网时代，移动互联网时代的峰值要来得更加凶猛。比如，2015年元月的流量到了平时的2倍，而峰值则达到了平时峰值的2倍，相当于平时正常流量的5倍，这对整个系统的考验是很残酷的。本次分享将简单介绍微信后台团队的开发模式、微信朋友圈的架构以及在性能上的一些工作，供各位参考。

##团队与技术栈简介

微信后台研发团队由三位工程师组成。开发模式采用了敏捷的方式，大概一个月一个小版本，一个季度出一个大版本，另外每天都会有不停的后台更新，很多是用户看不见的，也有一些是AB测试，比如选择一亿的用户，或者一定百分比的用户，或者一部分男性用户和女性用户来做AB测试。开发语言主要使用C++，正在往C++11上迁移，编译器在往GCC 4.8.2迁移。

服务器的配置基本都是普通的服务器，最好的服务器也就是64G内存，这部分占比不多，大部分是32G内存，也有很少一部分8G内存的。硬盘是SSD和SATA都有。CPU以16核居多，有一部分新机器是32核。至于带宽则是比较多的，对外带宽很大。

##微信朋友圈的架构概述

整个微信是微服务的架构，每一个请求后面可能会涉及到几百个服务，每一个服务都有一个QoS，目的是对一些重要的服务进行保证。比如除夕晚上流量达到平时的5倍，这时整个系统的性能肯定不够，所以要优先保证什么呢？优先保证支付，优先保证红包的体验。红包体验保证了，再保证消息，比如点对点两人之间的消息。这两个保证的前提下，再保证群聊。如果群聊也能保证，再保证朋友圈。性能不够时将优先级低的服务暂时停掉，这个过程是不需要人工干预的。

微信的架构跟普通的架构差不多，最上面是终端通过接入服务器接进来。接入层主要是长连接，长连接主要是为了安卓系统，一个是减少建立新连接的性能消耗，另一个是为了推送通知，因为Google服务在国内基本是不可用的，安卓系统上的推送通知都是用长连接完成。

然后到逻辑层。逻辑层包括注册、消息、群聊、朋友圈等等，还有iOS系统的通知。iOS系统跟安卓不一样在于，一个iOS App进入后台之后只有大概15秒的存活期，所以iOS上的推送通知要用API的Push完成，不在接入层做。

再往下走就是存储代理层，这一层主要负责一些关键数据的维护操作，比如用户在账号里面的动作操作和事故信息。存储代理层下面对接KV存储，这个KV存储是不负责业务逻辑的，只是单纯的Key-Value映射，以及负载均衡和容错。（有关KV存储系统的详细说明，可以参考微信架构师许家滔在QCon北京2014上的演讲“微信后台存储架构”。）

涉及朋友圈数据的有四个核心的表：

一个是发布。发布数据记录了来自所有用户所有的feed，比如一个用户发布了几张图片，每张图片的URL是什么，在CDN里的URL是什么，它有哪些元属性，谁可以看，谁不可以看等等。

一个是相册。相册是每个用户独立的，记录了该用户所发布的所有内容。

一个是评论。评论就是针对某个具体发布的朋友评论和点赞操作。

一个是时间线。所谓“刷朋友圈”，就是刷时间线，就是一个用户所有朋友的发布内容。

上面提到过，微信现在每天的发布有10亿多，浏览量超过100亿，对性能的要求很高，所以上面的存储都是做成可以水平扩展的。对于水平扩展的实现，下面举例说明。

##微信朋友圈的工作流程概述

比如有两个用户小王和Mary。小王和Mary各自有各自的相册，可能在同一台服务器上，也可能在不同的服务器上。现在小王上传了一张图片到自己的朋友圈。上传图片不经过微信后台服务器，而是直接上传到最近的腾讯CDN节点，所以非常快。图片上传到该CDN后，小王的微信客户端会通知微信的朋友圈CDN：这里有一个新的发布（比如叫K2），这个发布的图片URL是什么，谁能看到这些图片，等等此类的元数据，来把这个发布写到发布的表里。

在发布的表写完之后，会把这个K2的发布索引到小王的相册表里。所以相册表其实是很小的，里面只有索引指针。相册表写好了之后，会触发一个批处理的动作。这个动作就是去跟小王的每个好友说，小王有一个新的发布，请把这个发布插入到每个好友的时间线里面去。

然后比如说现在Mary上朋友圈了，而Mary是小王的一个好友。Mary拉自己的时间线的时候，时间线会告诉到有一个新的发布K2，然后Mary的微信客户端就会去根据K2的元数据去获取图片在CDN上的URL，把图片拉到本地。

在这个过程中，发布是很重的，因为一方面要写一个自己的数据副本，然后还要把这个副本的指针插到所有好友的时间线里面去。如果一个用户有几百个好友的话，这个过程会比较慢一些。这是一个单数据副本写扩散的过程。但是相对应的，读取就很简单了，每一个用户只需要读取自己的时间线表，就这一个动作就行，而不需要去遍历所有好友的相册表。

为什么选择这样一个写扩散的模型？因为读是有很多失败的。一个用户如果要去读两百个好友的相册表，极端情况下可能要去两百个服务器上去问，这个失败的可能性是很大的。但是写失败了就没关系，因为写是可以等待的，写失败了就重新去拷贝，直到插入成功为止。所以这样一个模型可以很大的减少服务的开销。

至于赞和评论的实现，是相对简单的。上面说了微信后台有一个专门的表存储评论和赞的数据，比如Kate是Mary和小王的朋友的话，刷到了K2这一条发布，就会同时从评论表里面拉取对应K2的、Mary留下的评论内容，插入到K2内容的下方。而如果另一个人不是Mary和小王的共同朋友，则不会看到这条评论。

##微信朋友圈的容灾

容灾有不同的层次，先看区域性的。微信在上海有一个IDC，该IDC是由三个独立的园区——A、B、C三个园区构成的。每一个园区都有独立的供电、制冷，独立的带宽，带宽同时连接联通、电信，而且每个园区的容量都有富余。三个园区直接有高速连接。所以无论任何一个区，比如C区整个不可用了，那么用户的客户端会自动连接到另外两个区，这两个区有足够的容量承载所有的服务。这种切换是无损的、无感知的。

第二个层次的容灾是跨地域的。微信最早在国内有一个上海的数据中心，这个数据中心承载了全国所有的用户。后来有一天上海来了个海啸还是什么的，所有数据都没了，于是后来在深圳又建立一个数据中心，上海服务北方用户，深圳服务南方。后来因为微信发展海外用户，于是在香港建立了第三个数据中心，主要服务东南亚、南亚、中东和非洲。后来在加拿大又建立了第四个数据中心，主要服务美洲和欧洲。

这第二个层次的数据中心跟上面说的园区不太一样。每一个微信用户事实上都属于一个特定的数据中心，比如两个北方的用户，他们的数据都在上海的数据中心，如果说上海数据中心跟其他数据中心的连接断了，这两个用户之间的通信是不会受到影响的。但如果有一个外国朋友在加拿大的数据中心，那么他跟国内用户的通信就可能受到影响。数据中心之间是有专线连接的，但实际上国内到国外的专线渠道并不太有保障，所以专线出问题的时候，两个数据中心之间的数据交换会切换到公网上，走普通的互联网。

新建一个数据中心涉及到很多同步，微信消息的数据同步是通过一个idcqueue组件实现的，是一个异步的数据同步方式。这个异步的写操作可能会由于网络阻塞或者其他原因，慢个一两秒种、几分钟甚至半天，但它会一直重试，能够保持正确性。而对于朋友圈来说，朋友圈是多数据副本的模型，那么多数据副本在跨数据中心同步的时候如何保证正确性，如何保证没有冲突？

解法其实也简单，只要单项同步最初的发布写操作。比如小王这个用户是在上海数据中心的，他在自己相册上新增了一条发布K2，那么就只要单项同步把K2写到香港去就好了。反过来，比如Mary是在香港，那么她有新的发布，只要在香港写进去之后，单项同步到上海就可以了。这样就不存在时间线多数据副本同步的问题了，只要在各个数据中心内分别做批处理。

当然有关这一块还有很多细节的问题，尤其是因为国内到国外的网络延迟很大，从大陆ping美国可能两百个毫秒，ping阿根廷或者南非可能有四百个毫秒，另外公网的丢包也比较严重，这对于数据同步的实现是很有影响的。这种情况就不适合用TCP了，TCP是针对大带宽、小延迟、有序的环境设计的，所以微信在跨数据中心做数据同步这一块就自己研发了一套类TCP的协议，这种协议对高延迟、高丢包有很高的容忍度，能够做到每秒同步几百兆到上G的数据。另一方面，由于从专线切换到公网存在信息安全隐患，这其中的数据加密也是很重要的一个工作。
